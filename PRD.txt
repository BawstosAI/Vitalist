Tu es Claude Code, assistant de code expert.

Je veux que tu gÃ©nÃ¨res, en **un seul coup**, la structure complÃ¨te dâ€™un projet de data science / machine learning autour de NHANES pour modÃ©liser le **vieillissement non linÃ©aire des organes**.

ðŸŽ¯ **Objectif du projet**

Construire, Ã  partir des donnÃ©es NHANES (cross-sectionnelles, multi-biomarqueurs), des **â€œorgan clocksâ€** :  
pour chaque organe / systÃ¨me, un modÃ¨le superviseÌ (non linÃ©aire) qui prÃ©dit lâ€™Ã¢ge chronologique Ã  partir des biomarqueurs liÃ©s Ã  cet organe.  

Ensuite :

- DÃ©finir pour chaque individu un **Ã¢ge biologique dâ€™organe** et un **AgeGap** = (Ã¢ge biologique dâ€™organe â€“ Ã¢ge rÃ©el).
- Ã‰tudier le **vieillissement diffÃ©rentiel des organes** (certains plus vieux / plus jeunes).
- Explorer des **profils de trajectoire** : quels organes â€œcassentâ€ en premier (approche pseudo-longitudinale par tranches dâ€™Ã¢ge).
- Utiliser clustering & UMAP **uniquement Ã  des fins dâ€™exploration/visualisation**, pas comme brique centrale du modÃ¨le.

Le projet doit Ãªtre **trÃ¨s explicable** :
- pour nous (comprendre chaque Ã©tape),
- pour un jury (quâ€™il entre dans le projet en 5â€“10 min via un notebook â€œnarratifâ€).

---

## ðŸ”§ HypothÃ¨ses & contraintes techniques

- Langage : **Python 3**.
- Utiliser **Jupyter notebooks** comme support principal dâ€™analyse.
- Le code doit Ãªtre **structurÃ©** dans un petit package Python rÃ©utilisable (`src/`), pour Ã©viter la rÃ©pÃ©tition dans les notebooks.
- Le projet doit pouvoir tourner **offline** : ne compte pas sur des tÃ©lÃ©chargements en ligne automatiques.
- HypothÃ¨se : les fichiers NHANES (XPT/CSV) sont dÃ©jÃ  prÃ©sents localement dans `data/raw/`.  
  â†’ Tu peux prÃ©voir un mÃ©canisme de configuration (YAML/JSON) pour :
  - les chemins vers les fichiers,
  - la liste des variables NHANES Ã  utiliser pour chaque organe.

- ModÃ¨les :
  - Baseline : rÃ©gression linÃ©aire / Elastic Net.
  - ModÃ¨le non linÃ©aire : Gradient Boosting (XGBoost ou LightGBM) ou, si plus simple, HistGradientBoosting Regressor de scikit-learn.
- ExplicabilitÃ© :
  - Comparaison **baseline linÃ©aire vs modÃ¨le non linÃ©aire**.
  - Importance des variables.
  - SHAP (ou au minimum permutation importance) pour interprÃ©ter les contributions des biomarqueurs.

- Visualisation : matplotlib et Ã©ventuellement plotly pour des graphes interactifs.

---

## ðŸ§¬ Concept mÃ©tier

Les donnÃ©es NHANES contiennent de nombreux biomarqueurs (sang, urine, examens physiques).  
On veut les organiser par **organes / systÃ¨mes** et entraÃ®ner, pour chaque panneau dâ€™organe :

> modÃ¨le_ML(organe O) : biomarqueurs_O (+ covariables globales) â†’ Ã¢ge chronologique

Lâ€™Ã¢ge prÃ©dit par le modÃ¨le dâ€™organe O pour lâ€™individu i = **Ã¢ge biologique de lâ€™organe O**.  
On dÃ©finit ensuite :

- `age_bio_O_i` = Ã¢ge biologique pour organe O et individu i,
- `age_gap_O_i = age_bio_O_i â€“ age_chrono_i`.

Ce vecteur dâ€™AgeGaps permet de :
- comparer les organes entre eux pour une personne,
- analyser les profils de vieillissement dans la population,
- explorer quels organes sont en avance/retard selon lâ€™Ã¢ge, le sexe, autres facteurs.

Important : NHANES est **cross-sectionnel** â†’ pas de suivi temporel rÃ©el.  
Les â€œtrajectoiresâ€ seront donc **pseudo-longitudinales**, Ã  partir de la coupe transversale par tranches dâ€™Ã¢ge.

---

## ðŸ“ Structure de projet attendue

Merci de gÃ©nÃ©rer un projet structurÃ© comme suit :

- `README.md`  
- `requirements.txt` ou `environment.yml`  
- `pyproject.toml` ou au minimum `setup.cfg` simple (optionnel si Ã§a complique)  
- `data/`
  - `raw/`        # fichiers NHANES bruts (non versionnÃ©s dans le repo, mais mentionnÃ©s dans README)
  - `interim/`    # donnÃ©es aprÃ¨s nettoyage / merge
  - `processed/`  # tables finales pour modeling (features par organe, etc.)
- `configs/`
  - `paths.yaml`          # chemins vers fichiers NHANES
  - `organ_panels.yaml`   # mapping organes â†” variables NHANES
- `notebooks/`
  - `00_overview_and_setup.ipynb`
  - `01_nhanes_data_preparation.ipynb`
  - `02_feature_engineering_organs.ipynb`
  - `03_train_organ_clocks.ipynb`
  - `04_analyze_agegaps.ipynb`
  - `05_trajectories_and_clustering.ipynb`
  - `06_jury_storytelling_report.ipynb`
- `src/organ_aging/`
  - `__init__.py`
  - `config.py`          # chargement YAML, gestion des chemins
  - `data_loading.py`    # lecture des fichiers NHANES (XPT/CSV) et merge
  - `preprocessing.py`   # nettoyage, filtrage, encodage variables
  - `features.py`        # construction des panneaux dâ€™organes et scaling
  - `models.py`          # entraÃ®nement et sauvegarde des modÃ¨les dâ€™organe
  - `evaluation.py`      # calcul AgeGaps, mÃ©triques, comparaisons
  - `explainability.py`  # SHAP / permutation importance, graphiques
  - `analysis.py`        # fonctions dâ€™analyses globales (corrÃ©lations, bins dâ€™Ã¢ge, etc.)
  - `visualization.py`   # fonctions gÃ©nÃ©riques de plotting (matplotlib/plotly)
  - `clustering.py`      # PCA/UMAP + clustering (usage exploratoire)

Tu peux ajuster lÃ©gÃ¨rement les noms si nÃ©cessaire, mais garde lâ€™esprit modulaire.

---

## ðŸ§¾ DÃ©tail des notebooks attendus

### `00_overview_and_setup.ipynb`
- Objectif : donner au lecteur (et au jury) une **vue dâ€™ensemble du projet**.
- Contenu :
  - Introduction texte (markdown) :
    - contexte : vieillissement diffÃ©rentiel des organes,
    - limitation : NHANES cross-sectionnel,
    - idÃ©e des organ clocks et des AgeGaps,
    - comment on va sâ€™y prendre en pipeline.
  - Cellules qui :
    - installent / importent les packages,
    - vÃ©rifient que `configs/paths.yaml` et `configs/organ_panels.yaml` existent,
    - affichent un schÃ©ma ASCII/markdown du pipeline global.

### `01_nhanes_data_preparation.ipynb`
- Utilise les fonctions de `src/organ_aging/data_loading.py` et `preprocessing.py`.
- Ã‰tapes :
  - Charger les fichiers NHANES (depuis `data/raw/`) selon `paths.yaml`.
  - Merger les tables (clÃ© `SEQN`) â†’ table large.
  - Nettoyage :
    - filtres de base (par ex. 18â€“80 ans),
    - gestion des missing values (stratÃ©gie simple mais expliquÃ©e),
    - encodage de variables catÃ©gorielles (sexe, ethnie, tabac, etc.).
  - Sauvegarder la table clean dans `data/interim/nhanes_clean.parquet` (par exemple).
- Beaucoup de markdown pour **expliquer chaque Ã©tape**, avec quelques stats de base (nombre de lignes, colonnes, % de NA).

### `02_feature_engineering_organs.ipynb`
- Utilise `features.py`.
- Ã‰tapes :
  - Charger `organ_panels.yaml` :
    - mapping de type :
      ```yaml
      liver:
        - ALT_varname
        - AST_varname
        - ...
      kidney:
        - ...
      cardio_metabolic:
        - ...
      immune:
        - ...
      global_covariates:
        - SEX
        - RACE
        - BMI
        - SMOKING_STATUS
      ```
    - Tu peux remplir ce YAML avec des **noms de variables gÃ©nÃ©riques** / placeholders, et commenter que lâ€™utilisateur doit les adapter Ã  ses fichiers NHANES.
  - Construire, pour chaque organe :
    - une matrice de features `X_organe`,
    - le vecteur cible `y = Ã¢ge`.
  - Appliquer :
    - scaling (StandardScaler/RobustScaler),
    - split train/validation/test (60/20/20, stratifiÃ© par dÃ©cennie dâ€™Ã¢ge si possible).
  - Sauvegarder dans `data/processed/` (par ex. un fichier par organe, ou un seul fichier avec colonnes marquÃ©es).

### `03_train_organ_clocks.ipynb`
- Utilise `models.py`, `evaluation.py`, `explainability.py`.
- Pour chaque organe :
  - EntraÃ®ner :
    - baseline linÃ©aire (LinearRegression ou ElasticNet),
    - modÃ¨le non linÃ©aire (XGBoost / LightGBM / HistGradientBoosting).
  - Stocker les modÃ¨les et scalers (pickle/joblib) dans un dossier `models/organ_name/`.
  - Calculer les mÃ©triques sur train/val/test :
    - MAE, RMSE, RÂ².
  - Produire un tableau comparatif baseline vs non linÃ©aire.
  - **ExplicabilitÃ©** :
    - au minimum : importance des features.
    - idÃ©al : SHAP summary plot pour chaque organe (ou un organe exemplaire) â†’ fonctions dans `explainability.py`.
- Beaucoup de markdown :
  - expliquer ce quâ€™est une clock dâ€™organe,
  - interprÃ©tation des mÃ©triques,
  - dÃ©montrer que le modÃ¨le non linÃ©aire capture la non-linÃ©aritÃ© (erreur rÃ©duite).

### `04_analyze_agegaps.ipynb`
- Utilise `evaluation.py` et `analysis.py`.
- Ã‰tapes :
  - Charger les prÃ©dictions des modÃ¨les pour chaque organe.
  - Calculer :
    - `age_bio_org`,
    - `age_gap_org` pour chaque individu.
  - Stocker une table `age_gaps.parquet` avec colonnes : ID (SEQN), Ã¢ge, organ_age / organ_gap, covariables.
  - Analyser :
    - distributions des AgeGaps par organe (histogrammes),
    - stats descriptives (moyenne, variance),
    - corrÃ©lations entre AgeGaps (heatmap).
  - Petite analyse par sexe / autres covariables si simple.

### `05_trajectories_and_clustering.ipynb`
- Utilise `analysis.py`, `clustering.py`, `visualization.py`.
- Important : le clustering est **exploratoire**, pas une brique modÃ¨le.
- Ã‰tapes :
  - Binner lâ€™Ã¢ge (par exemple : 18â€“30, 30â€“40, 40â€“50, etc.).
  - Pour chaque bin dâ€™Ã¢ge :
    - regarder la distribution des AgeGaps par organe,
    - voir comment Ã©volue la moyenne du gap avec lâ€™Ã¢ge.
  - DÃ©finir â€œorgane en avanceâ€ (ex. gap > +5 ans) â†’ analyser les co-occurrences :
    - combien de personnes ont foie en avance,
    - foie + rein,
    - cardio + immune, etc.
  - CrÃ©er, pour chaque individu, un vecteur :
    - `v = [gap_liver, gap_kidney, gap_cardio, gap_immune, ...]`.
  - Appliquer PCA ou UMAP sur ces vecteurs :
    - visualiser en 2D,
    - colorer par Ã¢ge, par organe â€œdominantâ€, etc.
  - Optionnel : KMeans ou HDBSCAN sur cet embedding, uniquement pour :
    - mettre des couleurs sur les points,
    - dÃ©crire des â€œprofils de vieillissementâ€.
- Markdown :
  - expliquer que ce nâ€™est pas un vrai modÃ¨le longitudinal,
  - bien poser les limites et la nature pseudo-longitudinale.

### `06_jury_storytelling_report.ipynb`
- Ce notebook est **pÃ©dagogique** et â€œprÃªt pour le pitchâ€.
- Contenu :
  - Rappel du problÃ¨me en 1â€“2 pages de markdown + quelques schÃ©mas simples.
  - RÃ©sumÃ© de la mÃ©thode :
    - organ clocks,
    - AgeGaps,
    - pseudo-trajectoires.
  - Quelques figures clÃ©s :
    - un exemple de SHAP plot,
    - un heatmap des AgeGaps pour quelques individus,
    - lâ€™embedding 2D (PCA/UMAP) colorÃ© par profil.
  - Conclusion :
    - ce que le projet montre,
    - limites,
    - pistes futures.

Le ton doit Ãªtre **clair, didactique**, en anglais (code et markdown)

## ðŸ§  ImplÃ©mentation des modules Python

Merci de gÃ©nÃ©rer le **contenu des fichiers** dans `src/organ_aging/` avec :

- Des **docstrings** clairs.
- Des **types hints** (typing) quand câ€™est pertinent.
- Des fonctions simples, testables :

Par exemple :

- `config.py`
  - fonction `load_paths_config()` â†’ charge `paths.yaml`.
  - fonction `load_organ_panels_config()` â†’ charge `organ_panels.yaml`.

- `data_loading.py`
  - fonction `load_nhanes_tables(paths_config: dict) -> Dict[str, pd.DataFrame]` :
    - lit les fichiers XPT/CSV dans `data/raw/`.
  - fonction `merge_nhanes_tables(tables_dict: dict) -> pd.DataFrame`.

- `preprocessing.py`
  - fonctions pour filtrer par Ã¢ge, gÃ©rer les NA, encoder les catÃ©gories.

- `features.py`
  - fonction `build_organ_datasets(df: pd.DataFrame, organ_panels: dict, global_covars: List[str]) -> Dict[str, Tuple[pd.DataFrame, pd.Series]]`.
  - fonction de split train/val/test.

- `models.py`
  - fonction `train_organ_models(organ_datasets: ...)` qui retourne et sauvegarde les modÃ¨les par organe.
  - choix clair des modÃ¨les (linÃ©aire + non linÃ©aire) pour chaque organe.

- `evaluation.py`
  - fonction `evaluate_models(...)` qui calcule MAE/RMSE/RÂ².
  - fonction `compute_age_bio_and_gaps(...)`.

- `explainability.py`
  - fonctions pour calculer et tracer :
    - feature importances,
    - SHAP summary (si bibliothÃ¨que SHAP dispo),
    - avec gestion du cas oÃ¹ SHAP nâ€™est pas installÃ© (instructions Ã  lâ€™utilisateur dans les docstrings).

- `analysis.py`
  - fonctions pour :
    - binning dâ€™Ã¢ge,
    - co-occurrence dâ€™organes en avance,
    - stats descriptives des AgeGaps.

- `clustering.py`
  - fonctions pour :
    - PCA / UMAP des vecteurs de gaps,
    - clustering (optionnel).

- `visualization.py`
  - fonctions de plotting gÃ©nÃ©riques (histos, scatter 2D, heatmaps).

---

## ðŸ“š README.md

GÃ©nÃ¨re aussi un `README.md` bien structurÃ© qui :

1. RÃ©sume le projet en quelques paragraphes (en franÃ§ais ou anglais, mais clair).
2. Explique :
   - le concept de clock dâ€™organe et dâ€™AgeGap,
   - la limitation cross-sectionnelle de NHANES,
   - lâ€™usage des notebooks.
3. Donne des instructions pour :
   - installer lâ€™environnement,
   - placer les fichiers NHANES dans `data/raw/`,
   - configurer `paths.yaml` et `organ_panels.yaml`,
   - exÃ©cuter les notebooks dans lâ€™ordre.
4. Met en avant le notebook `06_jury_storytelling_report.ipynb` comme point dâ€™entrÃ©e pour le jury.

---

## âš ï¸ Important

- Tu peux utiliser des **noms de variables NHANES gÃ©nÃ©riques ou typiques** (ALT, AST, etc.) dans `organ_panels.yaml`, mais indique clairement dans les commentaires que lâ€™utilisateur devra faire correspondre ces noms aux colonnes exactes de ses fichiers.
- PrioritÃ© : **clartÃ©, structure, explicabilitÃ©** > optimisation de performance.
- Le code doit Ãªtre lisible, commentÃ©, et Ã©viter la magie noire.

---

ðŸ‘‰ Ã€ partir de tout ce contexte, gÃ©nÃ¨re :
1. Lâ€™arborescence du projet.
2. Le contenu des principaux fichiers (`README.md`, `requirements.txt`, modules dans `src/organ_aging/`, squelette des notebooks avec les cellules Markdown de structure + quelques exemples de cellules de code).
3. Des commentaires TODO lÃ  oÃ¹ lâ€™utilisateur doit adapter manuellement (par ex. les vrais noms de colonnes NHANES).